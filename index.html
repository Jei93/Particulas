<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universo de Part√≠culas Controlado por Gestos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
            position: relative;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #video {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            transform: scaleX(-1);
            border: 2px solid #00ffff;
            border-radius: 8px;
            display: none;
        }
        
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .gesture-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ffff;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ffff;
            pointer-events: auto;
        }
        
        .gesture-indicator h3 {
            margin-bottom: 10px;
            color: #ffff00;
        }
        
        .gesture-item {
            margin: 5px 0;
            padding: 5px;
            opacity: 0.6;
            transition: opacity 0.3s;
        }
        
        .gesture-item.active {
            opacity: 1;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff00;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .control-panel button {
            margin: 5px;
            padding: 8px 15px;
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-panel button:hover {
            background: #00ff00;
            color: #000;
            transform: scale(1.05);
        }
        
        .status {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ff00ff;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff00ff;
            font-size: 12px;
        }
        
        .hand-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 3px solid #00ffff;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 20px #00ffff;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            text-align: center;
        }
        
        .bar {
            width: 200px;
            height: 4px;
            background: #003333;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ffff00);
            animation: loading 2s infinite;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 100%; }
            100% { width: 0%; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        CARGANDO SISTEMA DE GESTOS...
        <div class="bar"><div class="bar-fill"></div></div>
    </div>

    <div id="canvas-container"></div>
    <video id="video" autoplay></video>
    <div class="hand-cursor" id="handCursor"></div>

    <div id="ui-overlay">
        <div class="control-panel">
            <h3>üéÆ CONTROLES UNIVERSO</h3>
            <button onclick="toggleMode('gravity')">Modo Gravedad</button>
            <button onclick="toggleMode('repulsion')">Modo Repulsi√≥n</button>
            <button onclick="toggleMode('wave')">Modo Ondas</button>
            <button onclick="toggleMode('vortex')">Modo V√≥rtice</button>
            <button onclick="resetUniverse()">üîÑ Reset Universo</button>
            <button onclick="toggleVideo()">üìπ Mostrar C√°mara</button>
            <hr style="margin: 10px 0; border-color: #00ff00;">
            <p style="font-size: 11px; color: #888;">
                Gestos disponibles:<br>
                ‚Ä¢ <b>Pu√±o cerrado:</b> Atracci√≥n gravitatoria<br>
                ‚Ä¢ <b>Palma abierta:</b> Campo de repulsi√≥n<br>
                ‚Ä¢ <b>Dedo √≠ndice:</b> Seleccionar/estimar<br>
                ‚Ä¢ <b>‚úåÔ∏è Dos dedos:</b> Crear ondas<br>
                ‚Ä¢ <b>ü§ü Dos manos:</b> Zoom/escala
            </p>
        </div>

        <div class="gesture-indicator" id="gestureIndicator">
            <h3>ü§ö GESTOS DETECTADOS</h3>
            <div class="gesture-item" id="gesture-gravity">‚ö´ Gravedad: INACTIVO</div>
            <div class="gesture-item" id="gesture-repulsion">üåê Repulsi√≥n: INACTIVO</div>
            <div class="gesture-item" id="gesture-wave">„Ä∞Ô∏è Ondas: INACTIVO</div>
            <div class="gesture-item" id="gesture-vortex">üåÄ V√≥rtice: INACTIVO</div>
        </div>

        <div class="status" id="status">
            FPS: <span id="fps">0</span><br>
            Part√≠culas: <span id="particleCount">0</span><br>
            Hand API: <span id="handStatus">üî¥ Desconectado</span>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        // ==================== CONFIGURACI√ìN GLOBAL ====================
        const CONFIG = {
            particleCount: 15000,
            particleSize: 0.02,
            interactionRadius: 2.0,
            forceStrength: 0.5,
            damping: 0.95,
            colorModes: ['velocity', 'energy', 'cluster', 'gesture']
        };

        let scene, camera, renderer, particleSystem;
        let particles = [];
        let activeMode = 'gravity';
        let handLandmarks = null;
        let gestures = { gravity: false, repulsion: false, wave: false, vortex: false };
        let clock = new THREE.Clock();
        let fps = 0, frameCount = 0, lastTime = performance.now();

        // ==================== INICIALIZACI√ìN THREE.JS ====================
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000511);
            
            const container = document.getElementById('canvas-container');
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Luces
            scene.add(new THREE.AmbientLight(0x404040, 0.5));
            const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
            pointLight.position.set(0, 0, 5);
            scene.add(pointLight);

            createParticleSystem();
            createGridHelper();
        }

        // ==================== SISTEMA DE PART√çCULAS GPU ====================
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const velocities = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const energies = new Float32Array(CONFIG.particleCount);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // Posiciones iniciales esf√©ricas
                const radius = Math.random() * 3 + 1;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // Velocidades orbitales
                velocities[i3] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
                
                // Colores basados en posici√≥n
                colors[i3] = Math.abs(positions[i3]) / 3;
                colors[i3 + 1] = Math.abs(positions[i3 + 1]) / 3;
                colors[i3 + 2] = Math.abs(positions[i3 + 2]) / 3;
                
                sizes[i] = CONFIG.particleSize * (Math.random() * 0.5 + 0.5);
                energies[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('energy', new THREE.BufferAttribute(energies, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    gesturePos: { value: new THREE.Vector3(0, 0, 0) },
                    gestureStrength: { value: 0 },
                    activeMode: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute float energy;
                    varying vec3 vColor;
                    varying float vEnergy;
                    uniform float time;
                    uniform vec3 gesturePos;
                    uniform float gestureStrength;
                    uniform int activeMode;
                    
                    void main() {
                        vColor = color;
                        vEnergy = energy;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float distance = length(mvPosition.xyz - gesturePos);
                        
                        if (activeMode == 1) { // Gravity
                            if (distance < 5.0) {
                                gl_PointSize = size * (1.0 + gestureStrength * 2.0 / max(distance, 0.1));
                            } else {
                                gl_PointSize = size * 10.0;
                            }
                        } else if (activeMode == 2) { // Repulsion
                            gl_PointSize = size * 10.0 * (1.0 + gestureStrength * sin(time * 10.0 + energy * 10.0));
                        } else {
                            gl_PointSize = size * 10.0;
                        }
                        
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vEnergy;
                    uniform float time;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - (dist * 2.0);
                        alpha *= sin(vEnergy * 3.14159 + time) * 0.5 + 0.5;
                        
                        vec3 finalColor = vColor * (0.5 + vEnergy * 0.5);
                        gl_FragColor = vec4(finalColor, alpha * 0.8);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Almacenar referencias
            particles.positions = geometry.attributes.position.array;
            particles.velocities = geometry.attributes.velocity.array;
            particles.colors = geometry.attributes.color.array;
            particles.energies = geometry.attributes.energy.array;
            
            document.getElementById('particleCount').textContent = CONFIG.particleCount.toLocaleString();
        }

        // ==================== DETECCI√ìN DE GESTOS ====================
        async function initHandTracking() {
            const video = document.getElementById('video');
            
            // Configurar c√°mara
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: 640, height: 480 }
            });
            video.srcObject = stream;
            
            // Configurar MediaPipe Hands
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(onHandResults);
            
            const camera = new Camera(video, {
                onFrame: async () => await hands.send({ image: video }),
                width: 640,
                height: 480
            });
            
            await camera.start();
            document.getElementById('handStatus').innerHTML = 'üü¢ Conectado';
            console.log('‚úÖ Hand tracking iniciado');
        }

        function onHandResults(results) {
            handLandmarks = results.multiHandLandmarks;
            
            if (!handLandmarks || handLandmarks.length === 0) {
                resetGestures();
                return;
            }
            
            // Detectar gestos para cada mano
            handLandmarks.forEach((landmarks, handIndex) => {
                detectGestures(landmarks, handIndex);
            });
            
            updateHandCursor();
        }

        function detectGestures(landmarks, handIndex) {
            const thumb = landmarks[4];
            const index = landmarks[8];
            const middle = landmarks[12];
            const ring = landmarks[16];
            const pinky = landmarks[20];
            const wrist = landmarks[0];
            
            // Calcular si los dedos est√°n extendidos
            const isThumbExtended = thumb.y < landmarks[3].y;
            const isIndexExtended = index.y < landmarks[6].y;
            const isMiddleExtended = middle.y < landmarks[10].y;
            const isRingExtended = ring.y < landmarks[14].y;
            const isPinkyExtended = pinky.y < landmarks[18].y;
            
            const extendedCount = [isThumbExtended, isIndexExtended, isMiddleExtended, isRingExtended, isPinkyExtended]
                .filter(Boolean).length;
            
            // Normalizar coordenadas de la mano a coordenadas 3D
            const handX = (index.x - 0.5) * 10;
            const handY = -(index.y - 0.5) * 10;
            const handZ = (1 - index.z) * 5;
            
            // ===== DETECCI√ìN DE GESTOS ESPEC√çFICOS =====
            
            // 1. PU√ëO CERRADO - Gravedad
            if (extendedCount <= 1) {
                gestures.gravity = true;
                applyForceField(handX, handY, handZ, 'gravity');
            }
            
            // 2. PALMA ABIERTA - Repulsi√≥n
            if (extendedCount >= 4 && isIndexExtended && isMiddleExtended) {
                gestures.repulsion = true;
                applyForceField(handX, handY, handZ, 'repulsion');
            }
            
            // 3. DEDO √çNDICE APUNTANDO - Ondas
            if (isIndexExtended && !isMiddleExtended && extendedCount <= 2) {
                gestures.wave = true;
                createWave(handX, handY, handZ);
            }
            
            // 4. DOS MANOS - V√≥rtice / Escalado
            if (handLandmarks.length >= 2) {
                gestures.vortex = true;
                if (handIndex === 0) {
                    createVortex(handX, handY, handZ);
                }
            }
            
            // Actualizar uniformes del shader
            if (particleSystem) {
                particleSystem.material.uniforms.gesturePos.value.set(handX, handY, handZ);
                particleSystem.material.uniforms.gestureStrength.value = extendedCount / 5;
            }
        }

        function resetGestures() {
            gestures = { gravity: false, repulsion: false, wave: false, vortex: false };
            if (particleSystem) {
                particleSystem.material.uniforms.gestureStrength.value = 0;
            }
        }

        function updateHandCursor() {
            const cursor = document.getElementById('handCursor');
            if (handLandmarks && handLandmarks.length > 0) {
                const index = handLandmarks[0][8];
                const x = index.x * window.innerWidth;
                const y = index.y * window.innerHeight;
                cursor.style.left = x + 'px';
                cursor.style.top = y + 'px';
                cursor.style.display = 'block';
            } else {
                cursor.style.display = 'none';
            }
        }

        // ==================== F√çSICA DE PART√çCULAS ====================
        function applyForceField(x, y, z, type) {
            const positions = particles.positions;
            const velocities = particles.velocities;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                const dx = x - positions[i3];
                const dy = y - positions[i3 + 1];
                const dz = z - positions[i3 + 2];
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) + 0.1;
                
                if (distance < CONFIG.interactionRadius) {
                    const force = (1 - distance / CONFIG.interactionRadius) * CONFIG.forceStrength;
                    
                    if (type === 'gravity') {
                        velocities[i3] += dx * force * 0.001;
                        velocities[i3 + 1] += dy * force * 0.001;
                        velocities[i3 + 2] += dz * force * 0.001;
                    } else if (type === 'repulsion') {
                        velocities[i3] -= dx * force * 0.0005;
                        velocities[i3 + 1] -= dy * force * 0.0005;
                        velocities[i3 + 2] -= dz * force * 0.0005;
                    }
                }
            }
        }

        function createWave(x, y, z) {
            const positions = particles.positions;
            const time = clock.getElapsedTime();
            
            for (let i = 0; i < CONFIG.particleCount; i += 10) {
                const i3 = i * 3;
                const dx = x - positions[i3];
                const dy = y - positions[i3 + 1];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const wave = Math.sin(distance * 2 - time * 5) * 0.01;
                particles.velocities[i3 + 2] += wave;
            }
        }

        function createVortex(x, y, z) {
            const positions = particles.positions;
            const velocities = particles.velocities;
            
            for (let i = 0; i < CONFIG.particleCount; i += 5) {
                const i3 = i * 3;
                const dx = positions[i3] - x;
                const dy = positions[i3 + 1] - y;
                
                const angle = Math.atan2(dy, dx);
                const force = 0.01;
                
                velocities[i3] += Math.cos(angle + Math.PI / 2) * force;
                velocities[i3 + 1] += Math.sin(angle + Math.PI / 2) * force;
            }
        }

        // ==================== ACTUALIZACI√ìN DEL UNIVERSO ====================
        function updateParticles() {
            const positions = particles.positions;
            const velocities = particles.velocities;
            const dt = clock.getDelta();
            
            // Actualizar f√≠sica
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // Aplicar velocidad
                positions[i3] += velocities[i3];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];
                
                // Aplicar amortiguamiento
                velocities[i3] *= CONFIG.damping;
                velocities[i3 + 1] *= CONFIG.damping;
                velocities[i3 + 2] *= CONFIG.damping;
                
                // L√≠mites del universo (rebote)
                for (let j = 0; j < 3; j++) {
                    if (Math.abs(positions[i3 + j]) > 5) {
                        positions[i3 + j] = Math.sign(positions[i3 + j]) * 5;
                        velocities[i3 + j] *= -0.5;
                    }
                }
                
                // Actualizar colores basados en velocidad
                const speed = Math.sqrt(
                    velocities[i3] ** 2 + 
                    velocities[i3 + 1] ** 2 + 
                    velocities[i3 + 2] ** 2
                );
                
                particles.colors[i3] = Math.min(speed * 50, 1);
                particles.colors[i3 + 1] = 0.5;
                particles.colors[i3 + 2] = Math.max(1 - speed * 50, 0);
            }
            
            // Actualizar buffers
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.velocity.needsUpdate = true;
            
            // Rotaci√≥n base del sistema
            particleSystem.rotation.y += 0.001;
        }

        // ==================== UI Y CONTROLES ====================
        function toggleMode(mode) {
            activeMode = mode;
            particleSystem.material.uniforms.activeMode.value = 
                mode === 'gravity' ? 1 : 
                mode === 'repulsion' ? 2 : 
                mode === 'wave' ? 3 : 4;
            
            updateGestureUI();
        }

        function updateGestureUI() {
            const indicator = document.getElementById('gesture-indicator');
            Object.keys(gestures).forEach(gesture => {
                const element = document.getElementById(`gesture-${gesture}`);
                element.classList.toggle('active', gestures[gesture]);
                element.textContent = element.textContent.replace(/(INACTIVO|ACTIVO)/, 
                    gestures[gesture] ? 'ACTIVO' : 'INACTIVO');
            });
        }

        function resetUniverse() {
            createParticleSystem();
        }

        function toggleVideo() {
            const video = document.getElementById('video');
            video.style.display = video.style.display === 'none' ? 'block' : 'none';
        }

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = fps;
            }
        }

        function createGridHelper() {
            const gridHelper = new THREE.GridHelper(10, 20, 0x003366, 0x001133);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);
        }

        // ==================== BUCLE PRINCIPAL ====================
        function animate() {
            requestAnimationFrame(animate);
            
            updateParticles();
            updateGestureUI();
            updateFPS();
            
            if (particleSystem) {
                particleSystem.material.uniforms.time.value = clock.getElapsedTime();
            }
            
            renderer.render(scene, camera);
        }

        // ==================== INICIALIZACI√ìN ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Iniciar todo
        (async function init() {
            console.log('üöÄ Iniciando Universo de Part√≠culas...');
            
            initThreeJS();
            animate();
            
            try {
                await initHandTracking();
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('‚ùå Error al iniciar hand tracking:', error);
                document.getElementById('handStatus').innerHTML = 'üî¥ Error';
                document.getElementById('loading').innerHTML = `
                    <span style="color: red;">Error al acceder a la c√°mara</span><br>
                    <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #330000; color: #ff0000; border: 1px solid #ff0000; border-radius: 5px; cursor: pointer;">Reintentar</button>
                `;
            }
        })();
    </script>
</body>
</html>
